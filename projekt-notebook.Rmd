---
title: "Antarktyda"
output:
  html_document:
    df_print: paged
---

Wczytanie danych z plików .csv
```{r}
daily_ice_edge <- read.csv(file = 'data/daily_ice_edge.csv')
```


Rysowanie wykresów zasięgu pokrywy lodowej dla kolejnych wierszy (dat)
```{r}
# biblioteka do wykresów
library(plotly)
# przygotowwanie danych do stworzenia wykresów - usunięcie kolmny z datą
daily_ice_edge_df <- as.data.frame(daily_ice_edge)
daily_ice_edge_df <- subset(daily_ice_edge_df , select=-Date)

# wektor kątów
ang = c(0:360)
# WERSJA FUNKCJI UNIEZALEŻNIONA OD DANYCH - przyjmuje dowolne dane w formacie macierzy
# dzięki czemu można jej użyć też później
# zapisuje wyniki w odpowednich katalogach
plotIce <- function(angle, dataSource) {
  row <- dataSource[angle,]
  # delete -
  row <- abs(row)
  row <- as.numeric(row)
  # "odwrócenie" współrzędnych
  row = 90 -row
  # nazwy wykresów
  name <- paste("fig",angle, sep = "_")
  name <- paste(name, "png", sep = ".")
  print(name)
  # stworzenie wykresu
  fig <- plot_ly(
    type = 'scatterpolar',
    mode = 'lines',
    r = row,
    theta = ang,
    mode = 'markers'
  )
  # nazwa dataSource jako string
  dirName = deparse(substitute(dataSource))
  # zapis wykresu do odpowedniego kataogu o odpowedniej nazwie
  orca(fig, paste("charts/", dirName, "/",name, sep=""))
}
```

Szukanie najmniejszego zasięgu pokrywy lodowej poprzez znalezienie minimum w każdej kolumnie i stworzenie mapy z tych wartości
```{r}
# wektor na dane
minimalIceRange <- vector()
# wartośc bezwzględna
daily_ice_edge_df_abs <- abs(daily_ice_edge_df)
# przypisanie wartości max (czyli tak naprawdę min ze względu na abs)
for (colNum in 1:ncol(daily_ice_edge_df)) {
  minimalIceRange[colNum] <- max(daily_ice_edge_df_abs[,colNum])
}
minimalIceRange <- as.numeric(minimalIceRange)
# odwórcenie współrzednych
minimalIceRange <- 90 - minimalIceRange
# wektor kątów
ang = c(0:360)
# stworzenie wykresu
fig <- plot_ly(
  type = 'scatterpolar',
  mode = 'lines',
  r = minimalIceRange,
  theta = ang,
  mode = 'markers'
)
# parametry wykresu
fig <- fig %>%
  layout(polar = list(angularaxis = list(rotation = 90, direction  = 'clockwise')))

# margines dla tytułu
mrg <- list(l = 50, r = 50, b = 50, t = 50, pad = 20)
fig <- fig %>%
    layout(title = "Minimalny zasięg pokrywy lodowej Antarktydy dla lat 1978-2009",
         xaxis = list(title = ""),
         yaxis = list(title = ""),
         margin = mrg)

# zapis
orca(fig, 'charts/minimalIceRange.png')

```



```{r}
# przygotowanie zmiennej reprezentującej czas z uwzględnieniem tego, że w pewnym momencie dane są co jeden, a nie dwa dni
TimeSeq_1 <- seq(1,3180, 2)
TimeSeq_2 <- seq(3180, length(angle)+1590-1, 1)
TimeSeq <- c(TimeSeq_1, TimeSeq_2)

# funkcja szukająca modelu dla danego kąta długości geograficznej
findModel <- function(long) {
  angle <- daily_ice_edge[,long+1]
  # 2*pi*t/T
  xc<-cos(2*pi*TimeSeq/366)
  xs<-sin(2*pi*TimeSeq/366)
  fit <- lm(angle~xc+xs)

  #plot(TimeSeq,angle, xlim=c(1, 9000))
  #lines(TimeSeq,predict(fit), col="red")

  result <- predict(fit)
  return(result)
  
}

# zmienna na wygenerowane modele
models <- matrix(ncol=361, nrow=9530)
for (i in c(0:361)) {
  # wywólanie funkcji modelującej i dopisanie wszystkich modeli do macierzy
  models[,i] <- findModel(i)
}
# konwersja do dataFrame
models <- data.frame(models)
# zmiana nazw kolumn na takie reprezentujące kąty od 0 do 360
colnames(models) <- c(0:360)
```

Rysowanie wymodelwoanego zasięgu
```{r}
for (i in c(400:402)) {
  plotIce(i, models)
}

for (i in c(400:402)) {
  plotIce(i, daily_ice_edge_df)
}
```

```{r}

# wektor dat
daily_ice_edge_dates <- daily_ice_edge[,1]
# to string
daily_ice_edge_dates <- as.character(daily_ice_edge_dates)

# funkcja zbierająca wsztskie porpzednie operacje - rysuje zasięg rzeczywisty i model na tym samy wykresie 
plotDoubleIce <- function(angle, dataSource_1, dataSource_2, dates) {
  ang <- c(0:360)
  row_1 <- dataSource_1[angle,]
  row_2 <- dataSource_2[angle,]
  # usunięcie minusów
  row_1 <- abs(row_1)
  row_2 <- abs(row_2)
  row_1 <- as.numeric(row_1)
  row_2 <- as.numeric(row_2)
  # "odwrócenie" współrzędnych
  row_1 = 90 -row_1
  row_2 = 90 -row_2
  # nazwy wykresów (nazwa figTitle została tutaj przez niedpoatrzenie, powinno być fig ale niech już tak zostanie :) )
  name <- paste("figTitle",angle, sep = "_")
  name <- paste(name, "png", sep = ".")
  print(name)
  # stworzenie wykresu
  fig_1 <- plot_ly(
    type = 'scatterpolar',
    mode = 'lines',
    r = row_1,
    theta = ang,
    mode = 'markers',
    name = 'Zasięg rzeczywisty'
  )
  
  #fig_1 <- fig_1 %>% add_lines(name = ~"Zasięg rzeczywisty")
    
  fig_2 <- plot_ly(
    type = 'scatterpolar',
    mode = 'lines',
    r = row_2,
    theta = ang,
    mode = 'markers',
    name = 'Zasięg wymodelowany'
  )
  
  #fig_2 <- fig_2 %>% add_lines(name = ~"Zasięg wymodelowany")
  
  fig <- subplot(fig_1, fig_2)
  
  date <- dates[i]
  
  fig <- fig %>%
    layout(polar = list(angularaxis = list(
      rotation = 90,
      direction  = 'clockwise'
    )))
  
  currentDate <- dates[i]

  fig <- fig %>% layout(legend=list(title=list(text=paste("<b>", currentDate, "</b>", sep=""))))
  
    
  # get dataSource name as string
  dirName = "combinePlots"
  
  orca(fig, paste("charts/", dirName, "/",name, sep=""))
  
}


```

```{r}
# generowanie wszystkich klatek filmu - zasięg rzeczywisty + model
# z tego powstanie film przy pomocy ffmpeg
for (i in c(1:9530)) {
  plotDoubleIce(i, daily_ice_edge_df, models, daily_ice_edge_dates)
}
```





